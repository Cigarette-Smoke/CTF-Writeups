Link: https://play.picoctf.org/practice/challenge/438?category=6&page=1

# heap 0

Author: Abrxs, pr1or1tyQ

Difficulty: Easy

Description:

```
Are overflows just a stack concern?
Download the binary here.
Download the source here.
Connect with the challenge instance here:
nc tethys.picoctf.net XXXXX
```

## Source Code Analysis

```C
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64
// amount of memory allocated for input_data
#define INPUT_DATA_SIZE 5
// amount of memory allocated for safe_var
#define SAFE_VAR_SIZE 5

int num_allocs;
char *safe_var;
char *input_data;

void check_win() {
    if (strcmp(safe_var, "bico") != 0) {
        printf("\nYOU WIN\n");

        // Print flag
        char buf[FLAGSIZE_MAX];
        FILE *fd = fopen("flag.txt", "r");
        fgets(buf, FLAGSIZE_MAX, fd);
        printf("%s\n", buf);
        fflush(stdout);

        exit(0);
    } else {
        printf("Looks like everything is still secure!\n");
        printf("\nNo flage for you :(\n");
        fflush(stdout);
    }
}

void print_menu() {
    printf("\n1. Print Heap:\t\t(print the current state of the heap)"
           "\n2. Write to buffer:\t(write to your own personal block of data "
           "on the heap)"
           "\n3. Print safe_var:\t(I'll even let you look at my variable on "
           "the heap, "
           "I'm confident it can't be modified)"
           "\n4. Print Flag:\t\t(Try to print the flag, good luck)"
           "\n5. Exit\n\nEnter your choice: ");
    fflush(stdout);
}

void init() {
    printf("\nWelcome to heap0!\n");
    printf(
        "I put my data on the heap so it should be safe from any tampering.\n");
    printf("Since my data isn't on the stack I'll even let you write whatever "
           "info you want to the heap, I already took care of using malloc for "
           "you.\n\n");
    fflush(stdout);
    input_data = malloc(INPUT_DATA_SIZE);
    strncpy(input_data, "pico", INPUT_DATA_SIZE);
    safe_var = malloc(SAFE_VAR_SIZE);
    strncpy(safe_var, "bico", SAFE_VAR_SIZE);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}

void print_heap() {
    printf("Heap State:\n");
    printf("+-------------+----------------+\n");
    printf("[*] Address   ->   Heap Data   \n");
    printf("+-------------+----------------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+----------------+\n");
    printf("[*]   %p  ->   %s\n", safe_var, safe_var);
    printf("+-------------+----------------+\n");
    fflush(stdout);
}

int main(void) {

    // Setup
    init();
    print_heap();

    int choice;

    while (1) {
        print_menu();
	int rval = scanf("%d", &choice);
	if (rval == EOF){
	    exit(0);
	}
        if (rval != 1) {
            //printf("Invalid input. Please enter a valid choice.\n");
            //fflush(stdout);
            // Clear input buffer
            //while (getchar() != '\n');
            //continue;
	    exit(0);
        }

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print safe_var
            printf("\n\nTake a look at my variable: safe_var = %s\n\n",
                   safe_var);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}
```

- The goal is to make ```char *safe_var```, which is stored in heap memory, not be equal to "bico". How do we that? If we take a closer look we can see that the user can write to the buffer, specifically, to ```char *input_data```, which is located right under ```char *safe_var```.
- In order to understand why this is important, one must know:
1. [the memory layout of this program](https://www.geeksforgeeks.org/c/memory-layout-of-c-program/)
2. [buffers](https://www.geeksforgeeks.org/c/buffer-in-c-programming/)

- input_data is located right under safe_var in heap memory, therefore, if we input a string into write_buffer() that exceeds the amount of memory allocated for input_data, all of the memory that exceeds the limits will overflow from input_data into safe_var and rewrite it.
- INPUT_DATA_SIZE is 5 bytes, sooo logically the buffer overflow should happen at 6 bytes, right?
<img width="707" height="501" alt="image" src="https://github.com/user-attachments/assets/e9441dae-d1bd-47a1-812c-c4539a807184" />

- Nope. Now read this: https://sourceware.org/glibc/wiki/MallocInternals
- In simple words, the program allocates memory using malloc(), which automatically fills our 5 bytes of data with additional metadata all the way up to 32 bytes (16 bytes on 32 bit systems)
<img width="530" height="363" alt="image" src="https://github.com/user-attachments/assets/769e7e1d-d32a-4ee0-82ee-5d685e9dc78a" />

- ```CigaretteSmokeIsBadForYourHealth``` consists of 32 characters (i.e. 32 bytes), hence why only 228 was written to safe_var.
<img width="700" height="422" alt="image" src="https://github.com/user-attachments/assets/6aaa286c-bc58-40fa-9a2f-323adb3c38d0" />
